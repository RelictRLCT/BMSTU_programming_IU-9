;<буква>::=a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z
;<цифра>::=1|2|3|4|5|6|7|8|9|0
;<переменная>::=<буква>|<переменная><буква>
;<число>::=<цифра>|<число><цифра>|-<число>
;<знаки>::=+|-|*|/|^
;<скобки>::=(|)
;<допустимое>::=<переменная>|<число>
;<выраж>::=<допустимое>|<выраж><знаки><выраж>|(<выраж>)|E
;(load "trace.rkt")
;(load "unit-test2.rkt")

(define цифры '(#\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9 #\0))

(define знаки '(#\+ #\- #\* #\/ #\^))

(define minus '(#\-))

(define буквы '(#\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m
                    #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z #\A
                    #\B #\C #\D #\E #\F #\G #\H #\I #\J #\K
                    #\L #\M #\N #\O #\P #\Q #\R #\S #\T #\U #\V #\W #\X #\Y #\Z))

(define backtrack #f)

(define skob 0)

(define (error) (begin (set! skob 0) (backtrack #f)))

(define (tokenize str)
  (call-with-current-continuation
   (lambda (cc)
     (set! backtrack cc)
     (let loop ((str (string->list str))
                (пред #f)
                (tokens '())
                (perem "")
                (num "")
                (drtokens '()))
       (if (null? str)
           (if (and (= skob 0) (not (member пред знаки)))
               (if (not (equal? perem ""))
                   (append tokens (list (string->symbol perem)))
                   (if (not (equal? num ""))
                       (append tokens (list (string->number num)))
                       tokens))
               (error))
           (if (and (member (car str) знаки) (member пред знаки) (not (equal? (car str) #\-)))
               (error)
               (cond
                 ((equal? (car str) #\space)
                  (loop (cdr str) пред tokens perem num drtokens))                        
                 ((and (not (member (car str) буквы)) (not (null? (string->list perem))))
                  (begin (set! tokens (append tokens (list (string->symbol perem))))
                         (set! drtokens (append (list (string->symbol perem)) drtokens))
                         (loop str #f tokens "" num drtokens)))
                 ((and (not (member (car str) цифры))
                       (not (equal? (car str) #\e))
                       (not (equal? (car str) #\.))
                       (not (null? (string->list num))))
                  (if (equal? (car (reverse (string->list num))) #\e)
                      (error)
                      (begin (set! tokens (append tokens (list (string->number num))))
                             (set! drtokens (append (list (string->number num)) drtokens))
                             (loop str #f tokens perem "" drtokens))))
                 ((member (car str) знаки)
                  (if (and (and (not (null? drtokens)) (equal? (car drtokens) "("))
                           (not (equal? (car str) #\-)))
                      (error)
                      (if (or (and (null? drtokens) (not (equal? (car str) #\-))) (null? (cdr str)))
                          (error)
                          (begin (set! tokens
                                       (append tokens
                                               (list (string->symbol
                                                      (list->string (list (car str)))))))
                                 (set! drtokens (cons (car str) drtokens))
                                 (loop (cdr str) (car str) tokens "" "" drtokens)))))
                 ((equal? (car str) #\()
                  (if (or (and (null? (string->list perem)) (null? (string->list num)))
                          (and (not (null? drtokens)) (member (car drtokens) знаки)))
                      (begin (set! skob (+ skob 1))
                             (set! tokens (append tokens (list "(")))
                             (set! drtokens (append (list "(") drtokens))
                             (loop (cdr str) #f tokens "" "" drtokens))
                      (error)))
                 ((equal? (car str) #\)) (if (and (member "(" drtokens)
                                                  (not (member (car drtokens) знаки))
                                                  (not (equal? (car drtokens) "(")))
                                             (begin (set! skob (- skob 1))
                                                    (set! tokens (append tokens (list ")")))
                                                    (set! drtokens (append (list ")") drtokens))
                                                    (loop (cdr str) #f tokens "" "" drtokens))
                                             (error)))
                 ((and (equal? (car str) #\.) (not (null? (string->list num))))
                  (begin (set! num (string-append num (list->string (list (car str)))))
                         (loop (cdr str) #f tokens "" num drtokens)))
                 ((and (equal? (car str) #\e) (not (null? (string->list num)))
                       (member #\. (string->list num)))
                  (begin (set! num (string-append num (list->string (list (car str)))))
                         (loop (cdr str) #f tokens "" num drtokens)))
                 ((member (car str) буквы)
                  (begin (set! perem (string-append perem (list->string (list (car str)))))
                         (loop (cdr str) #f tokens perem "" drtokens)))
                 ((member (car str) цифры)
                  (begin (set! num (string-append num (list->string (list (car str)))))
                         (loop (cdr str) #f tokens "" num drtokens)))
                 (else (error)))))))))

(define new-znaki '(+ - / *))

(define new-cifri '(1 2 3 4 5 6 7 8 9 0))

(define (brack! tokens)
  (let loop ((str (cdr tokens))
             (count 1))
    (and (not (null? str))
         (cond
           ((and (equal? (car str) ")") (= count 1)) #t)
           ((equal? (car str) "(")
            (loop (cdr str) (+ count 1)))
           ((equal? (car str) ")")
            (loop (cdr str) (- count 1)))
           (else (loop (cdr str) count))))))

(define (countbr tokens)
  (let loop ((tokens tokens)
             (count 0))
    (if (not (null? tokens))
        (cond
          ((equal? (car tokens) "(")
           (loop (cdr tokens) (+ count 1)))
          ((equal? (car tokens) ")")
           (loop (cdr tokens) (- count 1)))
          (else  (loop (cdr tokens) count)))
        (= count 0))))

(define (parse tokens)

  (define (list! xs)
    (if (list? xs)
        xs
        (list xs)))
  
  (define (power)
    (let ((done tokens))
      (if (not (null? tokens))
          (begin (set! tokens (cdr tokens))
                 (cond
                   ((or (number? (car done))
                        (and (symbol? (car done))
                             (not (member (car done) new-znaki))))
                    (car done))
                   ((equal? (car done) '-)
                    (list '- (power)))
                   ((equal? (car done) "(")
                    (begin ;(set! tokens done)
                      (if (brack! tokens)
                          (expr #t)
                          (error))))
                   (else (error))))
          (error))))
  
  (define (factor)
    (let ((powpred (power)))
      (if (and (not (null? tokens))
               (equal? (car tokens) '^))
          (begin (set! tokens (cdr tokens))
                 (list powpred '^ (factor)))
          powpred)))

  (define (term)
    (let loop ((facpred (factor)))
      (if (not (null? tokens))
          (cond
            ((equal? (car tokens) '*)
             (begin (set! tokens (cdr tokens))
                    (if (and (not (null? tokens))
                             (not (member (car tokens) '(+ * /))))
                        (loop (list facpred '* (factor)))
                        (error))))
            ((equal? (car tokens) '/)
             (begin (set! tokens (cdr tokens))
                    (if (and (not (null? tokens))
                             (not (member (car tokens) '(+ * /))))
                        (loop (list facpred '/ (factor)))
                        (error))))
            (else facpred))
          facpred)))

  (define (expr bracket)
    (let loop ((termpred (term)))
      (if (not (null? tokens))
          (if (member (car tokens) '(+ -))
              (cond
                ((equal? (car tokens) '+)
                 (begin (set! tokens (cdr tokens))
                        (if (and (not (null? tokens))
                                 (not (member (car tokens) '(+ * /))))
                            (loop (list termpred '+ (term)))
                            (error))))
                ((equal? (car tokens) '-)
                 (begin (set! tokens (cdr tokens))
                        (if (and (not (null? tokens))
                                 (not (member (car tokens) '(+ * /))))
                            (loop (list termpred '- (term)))
                            (error))))
                (else termpred))
              ;(if (not (null? tokens))
              ;      (if (and (equal? (car tokens) ")")
              ;               bracket)
              ;          (begin (set! tokens (cdr tokens))
              ;                 termpred))
              (if (equal? (car tokens) ")")
                  (begin (set! tokens (cdr tokens))
                         (if (not (null? tokens))
                             (if (and (not (member (car tokens) new-znaki))
                                      (not (equal? (car tokens) '^))
                                      (not (equal? (car tokens) ")")))
                                 (error)
                                 termpred)
                             termpred))
                  termpred))
          termpred)))

  (call-with-current-continuation
   (lambda (cc)
     (set! backtrack cc)
     (if (not tokens)
         (error)
         (if (countbr tokens)
             (let ((done (expr #f)))
               (if (null? tokens)
                   done
                   (error)))
             (error))))))

(define (tree->scheme tree)
  (if (null? tree)
      '()
      (if (and (list? tree) (> (length tree) 2) (equal? (cadr tree) '^))
          (list 'expt (tree->scheme (car tree))
                (tree->scheme (caddr tree)))
          (if (and (list? tree) (> (length tree) 2))
              (list (cadr tree) (tree->scheme (car tree))
                    (tree->scheme (caddr tree)))
              (if (and (list? tree) (= (length tree) 2))
                  (list (car tree) (tree->scheme (cadr tree)))
                  tree)))))
